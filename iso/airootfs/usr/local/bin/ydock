#!/usr/bin/env python3
import gi
import cairo

gi.require_version("Gtk", "3.0")
gi.require_version("GtkLayerShell", "0.1")

from gi.repository import Gtk, Gdk, GtkLayerShell, Gio, GLib
import subprocess
import json
import os
import socket
import threading
import math
from pathlib import Path

CONFIG_FILE = Path.home() / ".config" / "ydock" / "config.json"


class DockIcon(Gtk.Button):
    def __init__(self, desktop_file, is_running, dock):
        super().__init__()
        self.desktop_file = desktop_file
        self.is_running = is_running
        self.dock = dock
        self.app_info = self.get_app_info()
        self.is_launching = False
        self._phase = 0
        
        self.set_relief(Gtk.ReliefStyle.NONE)
        self.set_focus_on_click(False)
        self.set_tooltip_text(self.app_info['name'])
        
        dock_size = dock.config.get('dock_size', 48)
        if self.app_info['icon']:
            try:
                image = Gtk.Image.new_from_icon_name(self.app_info['icon'], Gtk.IconSize.DIALOG)
                image.set_pixel_size(dock_size)
            except:
                image = Gtk.Image.new_from_icon_name("application-x-executable", Gtk.IconSize.DIALOG)
                image.set_pixel_size(dock_size)
        else:
            image = Gtk.Image.new_from_icon_name("application-x-executable", Gtk.IconSize.DIALOG)
            image.set_pixel_size(dock_size)
            
        if is_running:
            box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=4)
            box.pack_start(image, False, False, 0)

            dot = Gtk.DrawingArea()
            dot.set_size_request(4, 4)
            dot.set_halign(Gtk.Align.CENTER)

            import cairo
            def draw_dot(widget, cr):
                cr.set_source_rgba(0.3, 0.7, 1.0, 0.9)
                cr.arc(4, 4, 4, 0, 2 * 3.1416)
                cr.fill()
                return False

            dot.connect("draw", draw_dot)
            box.pack_start(dot, False, False, 0)

            box.show_all()
            self.add(box)
        else:
            box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=4)
            box.pack_start(image, False, False, 0)

            spacer = Gtk.Box()
            spacer.set_size_request(1, 8)  # same height as your dot + spacing
            box.pack_start(spacer, False, False, 0)

            box.show_all()
            self.add(box)

            
        self.connect("clicked", self.on_left_click)
        self.connect("button-press-event", self.on_button_press)

        # Enable file drop support
        self.drag_dest_set(Gtk.DestDefaults.ALL, [], Gdk.DragAction.COPY)
        self.drag_dest_add_uri_targets()
        self.connect("drag-data-received", self.on_file_drop)
        
        # Enable drag and drop only for pinned apps
        if self.desktop_file in dock.config['pinned_apps']:
            self.drag_source_set(Gdk.ModifierType.BUTTON1_MASK, [], Gdk.DragAction.MOVE)
            self.drag_source_add_text_targets()
            self.connect("drag-begin", self.on_drag_begin)
            self.connect("drag-data-get", self.on_drag_data_get)
            self.connect("drag-end", self.on_drag_end)
        
    def get_app_info(self):
        desktop_dirs = [
            Path("/usr/share/applications"),
            Path.home() / ".local/share/applications"
        ]
        
        for d in desktop_dirs:
            desktop_path = d / self.desktop_file
            if desktop_path.exists():
                try:
                    content = desktop_path.read_text()
                    icon = name = exec_cmd = ""
                    actions = []
                    
                    # Get locale
                    locale = os.environ.get('LANG', 'en').split('.')[0]
                    
                    lines = content.split('\n')
                    in_desktop_entry = False
                    
                    # Parse [Desktop Entry] section only
                    for line in lines:
                        if line.strip() == '[Desktop Entry]':
                            in_desktop_entry = True
                            continue
                        elif line.startswith('[') and in_desktop_entry:
                            in_desktop_entry = False
                            break
                        elif in_desktop_entry:
                            if line.startswith('Icon='):
                                icon = line.split('=', 1)[1].strip()
                            elif line.startswith('Name=') and not line.startswith('Name['):
                                name = line.split('=', 1)[1].strip()
                            elif line.startswith('Exec='):
                                exec_cmd = line.split('=', 1)[1].strip()
                            elif line.startswith('Actions='):
                                action_ids = line.split('=', 1)[1].strip().split(';')
                                actions = [aid for aid in action_ids if aid]
                    
                    # Parse actions from their respective sections
                    desktop_actions = []
                    for action_id in actions:
                        action_name = action_id
                        action_exec = ""
                        in_action_section = False
                        
                        for line in lines:
                            if line.strip() == f'[Desktop Action {action_id}]':
                                in_action_section = True
                                continue
                            elif line.startswith('[') and in_action_section:
                                in_action_section = False
                                break
                            elif in_action_section:
                                if line.startswith(f'Name[{locale}]='):
                                    action_name = line.split('=', 1)[1].strip()
                                elif line.startswith('Name=') and action_name == action_id:
                                    action_name = line.split('=', 1)[1].strip()
                                elif line.startswith('Exec='):
                                    action_exec = line.split('=', 1)[1].strip()
                        
                        if action_exec:
                            desktop_actions.append({'name': action_name, 'exec': action_exec})
                    
                    return {'icon': icon, 'name': name, 'exec': exec_cmd, 'actions': desktop_actions}
                except:
                    pass
        return {'icon': '', 'name': self.desktop_file, 'exec': '', 'actions': []}
        
    def on_left_click(self, button):
        if self.is_running:
            windows = self.get_app_windows()
            if len(windows) == 1:
                # Single window - focus it
                window = windows[0]
                if window['workspace'] == 99:  # Hidden
                    self.unhide_window(window['address'])
                else:
                    self.focus_window(window['address'])
            elif len(windows) > 1:
                # Multiple windows - show context menu
                class FakeEvent:
                    def __init__(self):
                        self.button = 1
                        self.time = Gtk.get_current_event_time()
                self.show_context_menu(FakeEvent())
        else:
            self.launch_app()
            
    def on_button_press(self, widget, event):
        if event.button == 3:  # Right click
            self.show_context_menu(event)
            return True
        return False
            
    def launch_app(self):
        if self.app_info['exec']:
            self.is_launching = True
            self.start_launch_animation()
            # Remove desktop entry field codes
            exec_cmd = self.app_info['exec']
            for code in ['%U', '%F', '%u', '%f', '%i', '%c', '%k']:
                exec_cmd = exec_cmd.replace(code, '')
            subprocess.Popen(exec_cmd.split())
    
    def start_launch_animation(self):
        """Start launching animation"""
        GLib.timeout_add(40, self.animate)
    
    def animate(self):
        """Animate icon with intense opacity and background pulse"""
        if not self.is_launching:
            self.set_opacity(1.0)
            self.get_style_context().remove_class('launching')
            return False
        
        self._phase = (self._phase + 0.15) % (2 * math.pi)
        # More intense opacity range: 0.3 to 1.0
        opacity = 0.3 + 0.7 * (0.5 + 0.5 * math.sin(self._phase))
        self.set_opacity(opacity)
        
        # Add/remove CSS class for background animation
        style_context = self.get_style_context()
        if math.sin(self._phase) > 0:
            style_context.add_class('launching')
        else:
            style_context.remove_class('launching')
        
        return True
    
    def stop_launch_animation(self):
        """Stop launching animation"""
        self.is_launching = False
        self.set_opacity(1.0)
        self.get_style_context().remove_class('launching')
        
    # --- MODIFIED: Improved window matching logic for Hyprland/WM classes ---
    def get_app_windows(self):
        try:
            result = subprocess.run(['hyprctl', 'clients', '-j'], capture_output=True, text=True)
            clients = json.loads(result.stdout)
            
            if not self.app_info['exec']:
                return []
            
            # 1. Get the primary executable name (e.g., 'mousepad' from Exec=mousepad %U)
            app_exec = self.app_info['exec'].split()[0].lower()
            
            windows = []
            for client in clients:
                client_class = client.get('class', '').lower()
                
                # Option A: Strict match with the application's executable name (Most common for Xfce/GTK apps)
                if client_class == app_exec:
                    windows.append({
                        'title': client.get('title', 'Untitled'),
                        'address': client.get('address', ''),
                        'workspace': client.get('workspace', {}).get('id', 1),
                        'hidden': client.get('hidden', False)
                    })
                    continue

                # Option B: Match using the app name from the desktop file stem (e.g., 'org.xfce.mousepad')
                desktop_stem_lower = self.desktop_file.replace('.desktop', '').lower()
                
                # Check if the client class is the app name *without* the prefix (e.g., 'mousepad' in 'org.xfce.mousepad')
                if client_class in desktop_stem_lower or desktop_stem_lower in client_class:
                    windows.append({
                        'title': client.get('title', 'Untitled'),
                        'address': client.get('address', ''),
                        'workspace': client.get('workspace', {}).get('id', 1),
                        'hidden': client.get('hidden', False)
                    })
            
            return windows
        except:
            return []
    # --- END MODIFIED SECTION ---
        
    def focus_window(self, address):
        subprocess.run(['hyprctl', 'dispatch', 'focuswindow', f'address:{address}'])
    
    def move_window_to_workspace(self, address, workspace):
        subprocess.run(['hyprctl', 'dispatch', 'movetoworkspacesilent', f'{workspace},address:{address}'])
    
    def get_current_workspace(self):
        try:
            result = subprocess.run(['hyprctl', 'activeworkspace', '-j'], capture_output=True, text=True)
            workspace = json.loads(result.stdout)
            return workspace.get('id', 1)
        except:
            return 1
    
    def hide_window(self, address):
        subprocess.run(['hyprctl', 'dispatch', 'movetoworkspacesilent', f'99,address:{address}'])
    
    def unhide_window(self, address):
        current_ws = self.get_current_workspace()
        subprocess.run(['hyprctl', 'dispatch', 'movetoworkspace', f'{current_ws},address:{address}'])
    
    def close_window(self, address):
        subprocess.run(['hyprctl', 'dispatch', 'closewindow', f'address:{address}'])
    
    def show_context_menu(self, event):
        menu = Gtk.Menu()
        menu.attach_to_widget(self, None)
        
        # Show windows first
        if self.is_running:
            windows = self.get_app_windows()
            if windows:
                for window in windows:
                    is_hidden = window['workspace'] == 99
                    window_item = Gtk.MenuItem(label=window['title'][:30] + ('...' if len(window['title']) > 30 else ''))
                    
                    # Create submenu for window operations
                    submenu = Gtk.Menu()
                    
                    # Focus (only if not hidden)
                    if not is_hidden:
                        focus_item = Gtk.MenuItem(label="Focus")
                        focus_item.connect("activate", lambda w, addr=window['address']: self.focus_window(addr))
                        submenu.append(focus_item)
                    
                    # Hide/Show
                    if is_hidden:
                        show_item = Gtk.MenuItem(label="Show")
                        show_item.connect("activate", lambda w, addr=window['address']: self.unhide_window(addr))
                        submenu.append(show_item)
                    else:
                        hide_item = Gtk.MenuItem(label="Hide")
                        hide_item.connect("activate", lambda w, addr=window['address']: self.hide_window(addr))
                        submenu.append(hide_item)
                    
                    # Close
                    close_item = Gtk.MenuItem(label="Close")
                    close_item.connect("activate", lambda w, addr=window['address']: self.close_window(addr))
                    submenu.append(close_item)
                    
                    # Move to workspace 1-7
                    submenu.append(Gtk.SeparatorMenuItem())
                    for ws in range(1, 8):
                        ws_item = Gtk.MenuItem(label=f"Move to workspace {ws}")
                        ws_item.connect("activate", lambda w, addr=window['address'], workspace=ws: self.move_window_to_workspace(addr, workspace))
                        submenu.append(ws_item)
                    
                    window_item.set_submenu(submenu)
                    menu.append(window_item)
                
                menu.append(Gtk.SeparatorMenuItem())
        
        # Actions from desktop file
        for action in self.app_info['actions']:
            action_item = Gtk.MenuItem(label=action['name'])
            action_item.connect("activate", lambda w, cmd=action['exec']: self.launch_action(cmd))
            menu.append(action_item)
        
        if self.app_info['actions']:
            menu.append(Gtk.SeparatorMenuItem())
        
        # Close action for running apps
        if self.is_running:
            close_item = Gtk.MenuItem(label="Close")
            close_item.connect("activate", self.on_close_app)
            menu.append(close_item)
            menu.append(Gtk.SeparatorMenuItem())
        
        # Pin/Unpin option
        is_pinned = self.desktop_file in self.dock.config['pinned_apps']
        pin_item = Gtk.MenuItem(label="Unpin" if is_pinned else "Pin")
        if is_pinned:
            pin_item.connect("activate", lambda w: self.dock.unpin_app(self.desktop_file))
        else:
            pin_item.connect("activate", lambda w: self.dock.pin_app(self.desktop_file))
        menu.append(pin_item)
        
        menu.show_all()
        menu.popup(None, None, None, None, event.button, event.time)
    
    def launch_action(self, exec_cmd):
        # Remove desktop entry field codes
        for code in ['%U', '%F', '%u', '%f', '%i', '%c', '%k']:
            exec_cmd = exec_cmd.replace(code, '')
        subprocess.Popen(exec_cmd.split())
    
    def on_close_app(self, menu_item):
        windows = self.get_app_windows()
        for window in windows:
            self.close_window(window['address'])
    
    def on_drag_begin(self, widget, context):
        self.dock.drag_source = self
        # Set drag icon
        if self.app_info['icon']:
            try:
                icon_theme = Gtk.IconTheme.get_default()
                pixbuf = icon_theme.load_icon(self.app_info['icon'], 48, 0)
                Gtk.drag_set_icon_pixbuf(context, pixbuf, 24, 24)
            except:
                pass
    
    def on_drag_data_get(self, widget, context, data, info, time):
        data.set_text(self.desktop_file, -1)
    
    def on_drag_end(self, widget, context):
        dock = self.dock
        drag_source = dock.drag_source

        if not drag_source:
            return

        # Restore all icons to full opacity immediately
        for child in dock.inner.get_children():
            if hasattr(child, 'set_opacity'):
                child.set_opacity(1.0)

        # Get current pointer position on screen
        display = Gdk.Display.get_default()
        seat = display.get_default_seat()
        device = seat.get_pointer()
        screen, x_root, y_root = device.get_position()

        # Συντεταγμένες dock
        alloc = dock.inner.get_allocation()
        win_x, win_y = dock.get_position()  # θέση του window στην οθόνη

        # Μετατροπή allocation σε συντεταγμένες οθόνης
        dock_x1 = win_x + alloc.x
        dock_y1 = win_y + alloc.y
        dock_x2 = dock_x1 + alloc.width
        dock_y2 = dock_y1 + alloc.height

        # Έλεγχος αν ο δείκτης είναι εκτός dock
        if not (dock_x1 <= x_root <= dock_x2 and dock_y1 <= y_root <= dock_y2):
            dock.unpin_app(drag_source.desktop_file)

        dock.drag_source = None
    
    def on_file_drop(self, widget, context, x, y, data, info, time):
        """Handle file drops on app icons"""
        uris = data.get_uris()
        if uris and self.app_info.get('exec'):
            files = []
            for uri in uris:
                if uri.startswith('file://'):
                    files.append(uri[7:])
            
            if files:
                cmd = ['gtk-launch', self.desktop_file] + files
                subprocess.Popen(cmd)
        
        Gtk.drag_finish(context, True, False, time)




class TrashIcon(Gtk.Button):
    def __init__(self, dock):
        super().__init__()
        self.dock = dock
        self.monitor = None
        
        self.set_relief(Gtk.ReliefStyle.NONE)
        self.set_focus_on_click(False)
        self.set_tooltip_text("Trash")
        
        self.update_icon()
        self.start_trash_monitor()
        
        self.connect("clicked", self.on_left_click)
        self.connect("button-press-event", self.on_button_press)
    
    def update_icon(self):
        # Check if trash has items
        trash_path = Path.home() / ".local/share/Trash/files"
        has_items = trash_path.exists() and any(trash_path.iterdir())
        
        icon_name = "user-trash-full" if has_items else "user-trash"
        dock_size = self.dock.config.get('dock_size', 48)
        image = Gtk.Image.new_from_icon_name(icon_name, Gtk.IconSize.DIALOG)
        image.set_pixel_size(dock_size)
        
        # Clear existing children and add new image
        for child in self.get_children():
            self.remove(child)
        
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=4)
        box.pack_start(image, False, False, 0)
        
        spacer = Gtk.Box()
        spacer.set_size_request(1, 8)
        box.pack_start(spacer, False, False, 0)
        
        box.show_all()
        self.add(box)
        
        # Enable file drop support for trash
        self.drag_dest_set(Gtk.DestDefaults.ALL, [], Gdk.DragAction.MOVE)
        self.drag_dest_add_uri_targets()
        self.connect("drag-data-received", self.on_file_drop)
    
    def on_left_click(self, button):
        subprocess.Popen(["thunar", "trash://"], stderr=subprocess.DEVNULL)
    
    def on_button_press(self, widget, event):
        if event.button == 3:  # Right click
            self.show_context_menu(event)
            return True
        return False
    
    def show_context_menu(self, event):
        # Check if trash has items
        trash_path = Path.home() / ".local/share/Trash/files"
        has_items = trash_path.exists() and any(trash_path.iterdir())
        
        if has_items:
            menu = Gtk.Menu()
            menu.attach_to_widget(self, None)
            empty_item = Gtk.MenuItem(label="Empty Trash")
            empty_item.connect("activate", self.empty_trash)
            menu.append(empty_item)
            menu.show_all()
            menu.popup(None, None, None, None, event.button, event.time)
    
    def empty_trash(self, menu_item):
        subprocess.Popen(["gio", "trash", "--empty"])
        GLib.timeout_add(500, self.update_icon)
    
    def start_trash_monitor(self):
        """Monitor trash directory for changes"""
        trash_path = Path.home() / ".local/share/Trash/files"
        if not trash_path.exists():
            trash_path.mkdir(parents=True, exist_ok=True)
        
        try:
            file = Gio.File.new_for_path(str(trash_path))
            self.monitor = file.monitor_directory(Gio.FileMonitorFlags.NONE, None)
            self.monitor.connect("changed", self.on_trash_changed)
        except Exception:
            pass
    
    def on_trash_changed(self, monitor, file, other_file, event_type):
        """Handle trash directory changes"""
        if event_type in [Gio.FileMonitorEvent.CREATED, Gio.FileMonitorEvent.DELETED]:
            GLib.idle_add(self.update_icon)
    
    def on_file_drop(self, widget, context, x, y, data, info, time):
        """Handle file drops on trash icon"""
        uris = data.get_uris()
        if uris:
            for uri in uris:
                if uri.startswith('file://'):
                    file_path = uri[7:]
                    subprocess.Popen(['gio', 'trash', file_path])
        
        Gtk.drag_finish(context, True, False, time)

class FolderMenuItem(Gtk.MenuItem):
    def __init__(self, folder_path, dock):
        super().__init__()
        self.folder_path = folder_path
        self.dock = dock
        
        hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        
        name_label = Gtk.Label(label=Path(folder_path).name)
        name_label.set_halign(Gtk.Align.START)
        hbox.pack_start(name_label, True, True, 0)
        
        select_button = Gtk.Button(label="Select")
        select_button.set_relief(Gtk.ReliefStyle.NONE)
        select_button.connect("clicked", self.on_select_clicked)
        hbox.pack_start(select_button, False, False, 0)
        
        self.add(hbox)
        
        # important! do not erase the following line
        self.connect("activate", self.on_select_clicked)
        
        self.show_all()
    
    def on_select_clicked(self, button):
        self.dock.add_folder(self.folder_path)
        menu = self.get_parent()
        while menu:
            if isinstance(menu, Gtk.Menu):
                menu.popdown()
                break
            menu = menu.get_parent()

class FolderIcon(Gtk.Button):
    def __init__(self, folder_path, dock):
        super().__init__()
        self.folder_path = folder_path
        self.dock = dock
        
        self.set_relief(Gtk.ReliefStyle.NONE)
        self.set_focus_on_click(False)
        self.set_tooltip_text(Path(folder_path).name)
        
        # A generic only icon would be:
        # image = Gtk.Image.new_from_icon_name("folder", Gtk.IconSize.DIALOG)
        
        # Determine the appropriate icon name
        folder_path_obj = Path(folder_path)
        home = Path.home()
        icon_name = "folder" # Default fallback icon name

        if folder_path_obj == home / "Downloads":
            icon_name = "folder-download"
        elif folder_path_obj == home / "Documents":
            icon_name = "folder-documents"
        elif folder_path_obj == home / "Pictures":
            icon_name = "folder-pictures"
        elif folder_path_obj == home / "Videos":
            icon_name = "folder-videos"
        elif folder_path_obj == home / "Music":
            icon_name = "folder-music"
        elif folder_path_obj == home / "Desktop":
            icon_name = "folder-desktop"
        
        # Create the image from the determined icon name
        dock_size = dock.config.get('dock_size', 48)
        image = Gtk.Image.new_from_icon_name(icon_name, Gtk.IconSize.DIALOG)
        image.set_pixel_size(dock_size)
        
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=4)
        box.pack_start(image, False, False, 0)
        
        spacer = Gtk.Box()
        spacer.set_size_request(1, 8)
        box.pack_start(spacer, False, False, 0)
        
        box.show_all()
        self.add(box)
        
        self.connect("clicked", self.on_left_click)
        self.connect("button-press-event", self.on_button_press)
        
        # Enable file drop support for folders
        self.drag_dest_set(Gtk.DestDefaults.ALL, [], Gdk.DragAction.COPY)
        self.drag_dest_add_uri_targets()
        self.connect("drag-data-received", self.on_file_drop)
    
    def on_left_click(self, button):
        self.show_folder_contents()
    
    def on_button_press(self, widget, event):
        if event.button == 3:  # Right click
            self.show_context_menu(event)
            return True
        return False
    
    def show_folder_contents(self):
        menu = Gtk.Menu()
        menu.attach_to_widget(self, None)
        
        try:
            folder = Path(self.folder_path)
            for item in sorted(folder.iterdir()):
                if item.is_file() or item.is_dir():
                    item_menu = Gtk.MenuItem()
                    
                    hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
                    
                    if item.is_dir():
                        icon = Gtk.Image.new_from_icon_name("folder", Gtk.IconSize.MENU)
                        hbox.pack_start(icon, False, False, 0)
                    
                    label = Gtk.Label(label=item.name)
                    label.set_halign(Gtk.Align.START)
                    hbox.pack_start(label, True, True, 0)
                    
                    item_menu.add(hbox)
                    item_menu.connect("activate", lambda w, path=str(item): subprocess.Popen(["xdg-open-younix", path]))
                    menu.append(item_menu)
        except:
            pass
        
        menu.show_all()
        menu.popup_at_widget(self, Gdk.Gravity.SOUTH, Gdk.Gravity.NORTH, None)
    
    def show_context_menu(self, event):
        menu = Gtk.Menu()
        menu.attach_to_widget(self, None)
        
        open_item = Gtk.MenuItem(label="Open Folder")
        open_item.connect("activate", lambda w: subprocess.Popen(["thunar", self.folder_path], stderr=subprocess.DEVNULL))
        menu.append(open_item)
        
        remove_item = Gtk.MenuItem(label="Remove from Dock")
        remove_item.connect("activate", lambda w: self.dock.remove_folder(self.folder_path))
        menu.append(remove_item)
        
        menu.show_all()
        menu.popup(None, None, None, None, event.button, event.time)
    
    def on_file_drop(self, widget, context, x, y, data, info, time):
        """Handle file drops on folder icons"""
        uris = data.get_uris()
        if uris:
            for uri in uris:
                if uri.startswith('file://'):
                    source_path = uri[7:]
                    subprocess.Popen(['cp', '-r', source_path, self.folder_path])
        
        Gtk.drag_finish(context, True, False, time)

class DockSeparator(Gtk.EventBox):
    def __init__(self, dock):
        super().__init__()
        self.dock = dock
        self.set_size_request(10, 48)
        separator = Gtk.Separator(orientation=Gtk.Orientation.VERTICAL)
        separator.set_margin_top(8)
        separator.set_margin_bottom(8)
        self.add(separator)
        
        self.connect("button-press-event", self.on_button_press)
        self.set_visible_window(True)
    
    def on_button_press(self, widget, event):
        if event.button == 3:  # Right click
            self.dock.show_dock_menu(event)
            return True
        return False
    
    def on_add_folder(self, menu_item):
        # Close menu first
        menu = menu_item.get_parent()
        if menu:
            menu.popdown()
        
        # Use GLib.idle_add to open dialog after menu closes
        GLib.idle_add(self._open_folder_dialog)
    
    def _open_folder_dialog(self):
        dialog = Gtk.FileChooserDialog(
            title="::Select Folder",
            parent=None,  # No parent to make it floating
            action=Gtk.FileChooserAction.SELECT_FOLDER
        )
        dialog.add_buttons(
            Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
            Gtk.STOCK_OPEN, Gtk.ResponseType.OK
        )
        
        # Center dialog on screen
        dialog.set_position(Gtk.WindowPosition.CENTER)
        
        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            folder_path = dialog.get_filename()
            self.dock.add_folder(folder_path)
        
        dialog.destroy()
        return False  # Don't repeat

class DockWindow(Gtk.Window):
    def __init__(self):
        super().__init__(type=Gtk.WindowType.TOPLEVEL)
        self.config = self.load_config()
        self.drag_source = None
        self.update_pending = False
        
        GtkLayerShell.init_for_window(self)
        GtkLayerShell.set_layer(self, GtkLayerShell.Layer.TOP)
        GtkLayerShell.set_exclusive_zone(self, 80)
        
        self.set_app_paintable(True)
        visual = self.get_screen().get_rgba_visual()
        if visual and self.get_screen().is_composited():
            self.set_visual(visual)
            
        self.set_name("ydock")
        
        self.inner_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=4)
        self.inner_box.set_name("dock-inner")
        self.inner_box.set_margin_top(5)
        self.inner_box.set_margin_bottom(0)
        self.inner_box.set_margin_start(15)
        self.inner_box.set_margin_end(15)
        
        # Create EventBox to catch clicks on empty area
        self.inner_event_box = Gtk.EventBox()
        self.inner_event_box.add(self.inner_box)
        self.inner_event_box.connect("button-press-event", self.on_dock_button_press)
        self.inner_event_box.set_events(Gdk.EventMask.BUTTON_PRESS_MASK)
        self.inner_event_box.set_visible_window(True)
        
        # Enable drop on the box
        self.inner_box.drag_dest_set(Gtk.DestDefaults.ALL, [], Gdk.DragAction.MOVE)
        self.inner_box.drag_dest_add_text_targets()
        self.inner_box.connect("drag-motion", self.on_drag_motion)
        self.inner_box.connect("drag-data-received", self.on_drag_data_received)
        
        self.inner = self.inner_box  # Keep name for consistency
        
        self.add(self.inner_event_box)
        
        # Apply saved position after inner is created
        self.apply_position(self.config.get('position', 'bottom'))
        
        self.update_dock()
        self.start_window_observer()
        self.update_panel_opacity()
        self.show_all()
        
    def load_config(self):
        if CONFIG_FILE.exists():
            config = json.loads(CONFIG_FILE.read_text())
            # Migrate old config format
            if 'pinned' in config and 'pinned_apps' not in config:
                config['pinned_apps'] = config.pop('pinned')
            if 'pinned_apps' not in config:
                config['pinned_apps'] = []
            if 'folders' not in config:
                config['folders'] = []
            if 'show_trash' not in config:
                config['show_trash'] = True
            if 'position' not in config:
                config['position'] = 'bottom'
            if 'panel_opacity' not in config:
                config['panel_opacity'] = 0.93
            if 'dock_size' not in config:
                config['dock_size'] = 48
            return config
        return {"pinned_apps": [], "folders": [], "show_trash": True, "icon_size": 48, "position": "bottom", "panel_opacity": 0.93, "dock_size": 48}
        
    def save_config(self):
        CONFIG_FILE.parent.mkdir(parents=True, exist_ok=True)
        CONFIG_FILE.write_text(json.dumps(self.config, indent=2))
        
    def pin_app(self, desktop_file):
        if desktop_file not in self.config['pinned_apps']:
            self.config['pinned_apps'].append(desktop_file)
            self.save_config()
            self.update_dock()
            
    def unpin_app(self, desktop_file):
        if desktop_file in self.config['pinned_apps']:
            self.config['pinned_apps'].remove(desktop_file)
            self.save_config()
            self.update_dock()
    
    def on_drag_motion(self, widget, context, x, y, time):
        if not self.drag_source or self.drag_source.desktop_file not in self.config['pinned_apps']:
            return False
        
        # Set dragged icon to full opacity
        self.drag_source.set_opacity(1.0)
        
        # Fade other icons to 0.7
        for child in self.inner.get_children():
            if child != self.drag_source and hasattr(child, 'set_opacity'):
                child.set_opacity(0.5)
        
        # Find drop position for reordering pinned apps only
        children = self.inner.get_children()
        pinned_children = [c for c in children if hasattr(c, 'desktop_file') and c.desktop_file in self.config['pinned_apps']]
        
        for i, child in enumerate(pinned_children):
            alloc = child.get_allocation()
            if x < alloc.x + alloc.width // 2:
                # Find actual position in all children
                actual_pos = children.index(child)
                self.inner.reorder_child(self.drag_source, actual_pos)
                break
        
        Gdk.drag_status(context, Gdk.DragAction.MOVE, time)
        return True
    

    def on_drag_data_received(self, widget, context, x, y, data, info, time):
        if not self.drag_source:
            return
        
        desktop_file = data.get_text()
        if not desktop_file or desktop_file not in self.config['pinned_apps']:
            return
        
        # Animate all icons back to full opacity
        self.animate_icons_to_full_opacity()
        
        # Reorder pinned apps based on current visual order
        children = self.inner.get_children()
        new_order = []
        for child in children:
            if (hasattr(child, 'desktop_file') and 
                child.desktop_file in self.config['pinned_apps']):
                new_order.append(child.desktop_file)
        
        self.config['pinned_apps'] = new_order
        self.save_config()
        
        Gtk.drag_finish(context, True, False, time)
    
    def animate_icons_to_full_opacity(self):
        """Animate all icons from 0.5 to 1.0 opacity"""
        def fade_step(step_count=[0]):
            step_count[0] += 1
            progress = step_count[0] / 10.0  # 10 steps
            opacity = 0.5 + (0.5 * progress)  # 0.5 → 1.0
            
            for child in self.inner.get_children():
                if hasattr(child, 'set_opacity'):
                    child.set_opacity(opacity)
            
            return step_count[0] < 10
        
        GLib.timeout_add(20, fade_step)
    
    def on_dock_button_press(self, widget, event):
        if event.button == 3:  # Right click
            self.show_dock_menu(event)
            return True
        return False
    
    def show_dock_menu(self, event):
        menu = Gtk.Menu()
        menu.attach_to_widget(self, None)
        
        # Add Folder
        add_folder_item = Gtk.MenuItem(label="Add Folder")
        folder_submenu = Gtk.Menu()
        self.create_folder_submenu(folder_submenu, Path.home())
        add_folder_item.set_submenu(folder_submenu)
        menu.append(add_folder_item)
        
        # Dock Place
        dock_place_item = Gtk.MenuItem(label="Dock Place")
        dock_submenu = Gtk.Menu()
        
        bottom_item = Gtk.MenuItem(label="Bottom")
        bottom_item.connect("activate", lambda w: self.set_position("bottom"))
        dock_submenu.append(bottom_item)
        
        left_item = Gtk.MenuItem(label="Left")
        left_item.connect("activate", lambda w: self.set_position("left"))
        dock_submenu.append(left_item)
        
        right_item = Gtk.MenuItem(label="Right")
        right_item.connect("activate", lambda w: self.set_position("right"))
        dock_submenu.append(right_item)
        
        dock_place_item.set_submenu(dock_submenu)
        menu.append(dock_place_item)
        
        # Recycle Bin
        recycle_item = Gtk.MenuItem(label="Recycle Bin")
        recycle_submenu = Gtk.Menu()
        
        show_trash = self.config.get('show_trash', True)
        if show_trash:
            hide_item = Gtk.MenuItem(label="Hide")
            hide_item.connect("activate", lambda w: self.toggle_trash(False))
            recycle_submenu.append(hide_item)
        else:
            show_item = Gtk.MenuItem(label="Show")
            show_item.connect("activate", lambda w: self.toggle_trash(True))
            recycle_submenu.append(show_item)
        
        recycle_item.set_submenu(recycle_submenu)
        menu.append(recycle_item)
        
        # Panel Opacity dialog
        opacity_item = Gtk.MenuItem(label="Transparency...")
        opacity_item.connect("activate", lambda w: GLib.idle_add(self.show_transparency_dialog))
        menu.append(opacity_item)
        
        # Dock Size dialog
        size_item = Gtk.MenuItem(label="Dock Size...")
        size_item.connect("activate", lambda w: GLib.idle_add(self.show_size_dialog))
        menu.append(size_item)
        
        menu.show_all()
        menu.popup(None, None, None, None, event.button, event.time)
    

    
    def create_folder_submenu(self, menu, folder_path):
        try:
            current_folder_item = FolderMenuItem(str(folder_path), self)
            menu.append(current_folder_item)
            menu.append(Gtk.SeparatorMenuItem())
            
            for item in sorted(folder_path.iterdir()):
                if item.is_dir() and not item.name.startswith('.'):
                    try:
                        has_subfolders = any(d.is_dir() for d in item.iterdir() if not d.name.startswith('.'))
                    except:
                        has_subfolders = False
                    
                    if has_subfolders:
                        menu_item = Gtk.MenuItem(label=item.name)
                        submenu = Gtk.Menu()
                        self.create_folder_submenu(submenu, item)
                        menu_item.set_submenu(submenu)
                        menu.append(menu_item)
                    else:
                        folder_item = FolderMenuItem(str(item), self)
                        menu.append(folder_item)
        except:
            pass
            
    def get_running_apps(self):
        try:
            result = subprocess.run(['hyprctl', 'clients', '-j'], capture_output=True, text=True)
            clients = json.loads(result.stdout)
            
            running_classes = set()
            for client in clients:
                if 'class' in client and client['class']:
                    running_classes.add(client['class'])
            
            desktop_files = []
            for class_name in running_classes:
                desktop_file = self.find_desktop_file(class_name)
                if desktop_file:
                    desktop_files.append(desktop_file)
            
            return desktop_files
        except:
            return []
    
    def find_desktop_file(self, class_name):
        desktop_dirs = [
            Path("/usr/share/applications"),
            Path.home() / ".local/share/applications"
        ]
        
        class_name = class_name.lower()
        
        # Candidate for the best match
        best_match = None

        for d in desktop_dirs:
            if not d.exists():
                continue
            for desktop_file in d.glob("*.desktop"):
                desktop_stem_lower = desktop_file.stem.lower()

                # Skip files clearly marked as utilities/actions based on file name
                if desktop_stem_lower.endswith(('-settings', '-preferences', '-bulk-rename', '-action')):
                    continue
                
                try:
                    lines = desktop_file.read_text().splitlines()

                    in_main = False
                    startup_wmclass = None
                    exec_cmd = None

                    for line in lines:
                        if line.strip() == "[Desktop Entry]":
                            in_main = True
                            continue
                        elif line.startswith("[") and in_main:
                            break
                        elif in_main:
                            if line.startswith("StartupWMClass="):
                                startup_wmclass = line.split("=",1)[1].strip().lower()
                            elif line.startswith("Exec="):
                                exec_cmd = line.split("=",1)[1].strip()

                    # 1. Match StartupWMClass (strict)
                    if startup_wmclass and startup_wmclass == class_name:
                        return desktop_file.name # Immediate, strong match

                    # 2. Match desktop file stem (strict)
                    if desktop_stem_lower == class_name:
                        return desktop_file.name # Immediate, strong match

                    # 3. Fallback: Match based on Class Name (e.g., 'mousepad' in 'org.xfce.mousepad')
                    if class_name in desktop_stem_lower or desktop_stem_lower in class_name:
                        # Prioritize the current match if it is shorter (usually the main app)
                        if best_match is None or len(desktop_stem_lower) < len(best_match):
                            best_match = desktop_stem_lower

                    # 4. Fallback: Match based on Executable Name (e.g., 'thunar' from Exec=thunar %F)
                    if exec_cmd:
                        executable_name = exec_cmd.split()[0].lower()
                        if executable_name == class_name:
                            # Prioritize the current match if it is shorter (usually the main app)
                            if best_match is None or len(desktop_stem_lower) < len(best_match):
                                best_match = desktop_stem_lower
                        
                except:
                    continue
        
        # Return the shortest, best match found in the fallbacks
        if best_match:
            return best_match + ".desktop"

        return None

        
    def update_dock(self):
        for child in self.inner.get_children():
            self.inner.remove(child)
            
        running_apps = self.get_running_apps()
        
        # Add YoUNiX-Launcher.desktop as first item
        launcher_icon = DockIcon('YoUNiX-Launcher.desktop', False, self)
        self.inner.pack_start(launcher_icon, False, False, 0)
        
        # Add pinned apps
        for desktop_file in self.config['pinned_apps']:
            is_running = desktop_file in running_apps
            icon = DockIcon(desktop_file, is_running, self)
            self.inner.pack_start(icon, False, False, 0)
        
        # Add separator if there are pinned apps and running apps
        unpinned_running = [app for app in running_apps if app not in self.config['pinned_apps']]
        if self.config['pinned_apps'] and unpinned_running:
            separator = DockSeparator(self)
            self.inner.pack_start(separator, False, False, 0)
        
        # Add unpinned running apps
        for desktop_file in unpinned_running:
            icon = DockIcon(desktop_file, True, self)
            self.inner.pack_start(icon, False, False, 0)
        
        # Add separator between running apps and folders
        if (self.config['pinned_apps'] or unpinned_running) and self.config['folders']:
            separator = DockSeparator(self)
            self.inner.pack_start(separator, False, False, 0)
        
        # Add folders
        for folder_path in self.config['folders']:
            folder_icon = FolderIcon(folder_path, self)
            self.inner.pack_start(folder_icon, False, False, 0)
        
        # Add separator before trash if there are any items
        if self.config['pinned_apps'] or unpinned_running or self.config['folders']:
            separator = DockSeparator(self)
            self.inner.pack_start(separator, False, False, 0)
        
        # Add trash icon if enabled
        if self.config['show_trash']:
            if not hasattr(self, 'trash_icon'):
                self.trash_icon = TrashIcon(self)
            else:
                self.trash_icon.update_icon()
            self.inner.pack_start(self.trash_icon, False, False, 0)
            
        self.show_all()
        return True
    
    def add_folder(self, folder_path):
        if folder_path not in self.config['folders']:
            self.config['folders'].append(folder_path)
            self.save_config()
            self.update_dock()
    
    def remove_folder(self, folder_path):
        if folder_path in self.config['folders']:
            self.config['folders'].remove(folder_path)
            self.save_config()
            self.update_dock()
    
    def toggle_trash(self, show):
        self.config['show_trash'] = show
        self.save_config()
        self.update_dock()
    
    def apply_position(self, position):
        # Clear current anchors
        GtkLayerShell.set_anchor(self, GtkLayerShell.Edge.BOTTOM, False)
        GtkLayerShell.set_anchor(self, GtkLayerShell.Edge.LEFT, False)
        GtkLayerShell.set_anchor(self, GtkLayerShell.Edge.RIGHT, False)
        GtkLayerShell.set_anchor(self, GtkLayerShell.Edge.TOP, False)
        
        if position == "bottom":
            GtkLayerShell.set_anchor(self, GtkLayerShell.Edge.BOTTOM, True)
            self.inner.set_orientation(Gtk.Orientation.HORIZONTAL)
            self.inner.set_margin_start(15)
            self.inner.set_margin_end(15)
        elif position == "left":
            GtkLayerShell.set_anchor(self, GtkLayerShell.Edge.LEFT, True)
            GtkLayerShell.set_anchor(self, GtkLayerShell.Edge.TOP, True)
            GtkLayerShell.set_anchor(self, GtkLayerShell.Edge.BOTTOM, True)
            self.inner.set_orientation(Gtk.Orientation.VERTICAL)
            self.inner.set_margin_start(0)
            self.inner.set_margin_end(15)
        elif position == "right":
            GtkLayerShell.set_anchor(self, GtkLayerShell.Edge.RIGHT, True)
            GtkLayerShell.set_anchor(self, GtkLayerShell.Edge.TOP, True)
            GtkLayerShell.set_anchor(self, GtkLayerShell.Edge.BOTTOM, True)
            self.inner.set_orientation(Gtk.Orientation.VERTICAL)
            self.inner.set_margin_start(15)
            self.inner.set_margin_end(0)
    
    def set_position(self, position):
        self.config['position'] = position
        self.save_config()
        self.apply_position(position)
    
    def set_panel_opacity(self, opacity):
        self.config['panel_opacity'] = opacity
        self.save_config()
        self.update_panel_opacity()
    
    def update_panel_opacity(self):
        opacity = self.config.get('panel_opacity', 0.93)
        css = f"""
        #dock-inner {{
            background-color: rgba(15, 18, 28, {opacity});
        }}
        """
        
        style_provider = Gtk.CssProvider()
        style_provider.load_from_data(css.encode())
        
        screen = Gdk.Screen.get_default()
        Gtk.StyleContext.add_provider_for_screen(
            screen,
            style_provider,
            Gtk.STYLE_PROVIDER_PRIORITY_USER + 1,
        )
    
    def start_window_observer(self):
        """Start listening to Hyprland window events"""
        def observer_thread():
            socket_path = self.get_hyprland_socket()
            if not socket_path:
                return
            
            try:
                sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
                sock.connect(socket_path)
                
                while True:
                    data = sock.recv(1024).decode('utf-8')
                    if not data:
                        break
                    
                    for line in data.strip().split('\n'):
                        if line.startswith('openwindow>>'):
                            self.handle_window_open(line)
                            self.schedule_update()
                        elif line.startswith('closewindow>>'):
                            self.schedule_update()
                            
            except Exception:
                pass
            finally:
                sock.close()
        
        thread = threading.Thread(target=observer_thread, daemon=True)
        thread.start()
    
    def schedule_update(self):
        """Schedule dock update with debouncing"""
        if not self.update_pending:
            self.update_pending = True
            GLib.timeout_add(100, self.debounced_update)
    
    def debounced_update(self):
        """Debounced update function"""
        self.update_pending = False
        self.update_dock()
        return False
    
    def handle_window_open(self, event):
        """Handle window open event and stop launch animations"""
        try:
            # Parse: openwindow>>ADDRESS,WORKSPACENAME,WINDOWCLASS,WINDOWTITLE
            parts = event.replace('openwindow>>', '').split(',', 3)
            if len(parts) >= 3:
                window_class = parts[2].lower()
                
                # Stop launch animation for matching apps
                for child in self.inner.get_children():
                    if hasattr(child, 'is_launching') and child.is_launching:
                        if hasattr(child, 'app_info') and child.app_info.get('exec'):
                            app_exec = child.app_info['exec'].split()[0].lower()
                            desktop_stem = child.desktop_file.replace('.desktop', '').lower()
                            
                            if (window_class == app_exec or 
                                window_class in desktop_stem or 
                                desktop_stem in window_class):
                                child.stop_launch_animation()
        except Exception:
            pass
    
    def get_hyprland_socket(self):
        """Get Hyprland IPC socket path"""
        import glob
        
        # Try environment variable first
        signature = os.environ.get('HYPRLAND_INSTANCE_SIGNATURE')
        if signature:
            socket_path = f"/run/user/{os.getuid()}/hypr/{signature}/.socket2.sock"
            if os.path.exists(socket_path):
                return socket_path
        
        # Fallback: find any Hyprland socket
        sockets = glob.glob(f"/run/user/{os.getuid()}/hypr/*/.socket2.sock")
        if sockets:
            return sockets[0]
        
        return None
    
    def show_transparency_dialog(self):
        dialog = Gtk.Dialog(title=":YoUNiX-Dock-Prefs", parent=self, modal=True)
        dialog.set_default_size(300, 100)
        dialog.set_position(Gtk.WindowPosition.CENTER_ON_PARENT)
        dialog.set_keep_above(True)
        dialog.set_type_hint(Gdk.WindowTypeHint.DIALOG)
        
        content_area = dialog.get_content_area()
        content_area.set_spacing(10)
        content_area.set_margin_top(20)
        content_area.set_margin_bottom(20)
        content_area.set_margin_start(20)
        content_area.set_margin_end(20)
        
        label = Gtk.Label(label="Adjust panel transparency:")
        content_area.pack_start(label, False, False, 0)
        
        adjustment = Gtk.Adjustment(value=self.config.get('panel_opacity', 0.93),
                                    lower=0.1, upper=1.0, step_increment=0.05)
        scale = Gtk.Scale(orientation=Gtk.Orientation.HORIZONTAL, adjustment=adjustment)
        scale.set_digits(2)
        scale.set_hexpand(True)
        scale.connect("value-changed", lambda s: self.set_panel_opacity(s.get_value()))
        content_area.pack_start(scale, True, True, 0)
        
        dialog.add_button("Close", Gtk.ResponseType.CLOSE)
        dialog.show_all()
        
        dialog.run()
        dialog.destroy()
    
    def show_size_dialog(self):
        """Show dock size dialog"""
        dialog = Gtk.Dialog(title=":YoUNiX-Dock-Prefs", modal=True)
        dialog.set_default_size(300, 100)
        dialog.set_position(Gtk.WindowPosition.CENTER_ALWAYS)
        dialog.set_keep_above(True)
        dialog.set_type_hint(Gdk.WindowTypeHint.DIALOG)
        dialog.present()
        
        content_area = dialog.get_content_area()
        content_area.set_spacing(10)
        content_area.set_margin_top(20)
        content_area.set_margin_bottom(20)
        content_area.set_margin_start(20)
        content_area.set_margin_end(20)
        
        label = Gtk.Label(label="Adjust dock size:")
        content_area.pack_start(label, False, False, 0)
        
        adjustment = Gtk.Adjustment(value=self.config.get('dock_size', 48),
                                  lower=24, upper=96, step_increment=4)
        scale = Gtk.Scale(orientation=Gtk.Orientation.HORIZONTAL, adjustment=adjustment)
        scale.set_digits(0)
        scale.set_hexpand(True)
        scale.connect("value-changed", lambda s: self.set_dock_size(int(s.get_value())))
        content_area.pack_start(scale, True, True, 0)
        
        dialog.add_button("Close", Gtk.ResponseType.CLOSE)
        dialog.show_all()
        
        dialog.run()
        dialog.destroy()
    
    def set_dock_size(self, size):
        """Set dock icon size"""
        self.config['dock_size'] = size
        self.save_config()
        self.update_dock()



def add_css():
    css = b"""
    #ydock {
        background: transparent;
    }

    #dock-inner {
        background-color: rgba(15, 18, 28, 0.93);
        border-radius: 20px;
        padding: 5px 10px 0px 10px;
    }

    #dock-inner button {
        background: transparent;
        border: none;
        border-radius: 14px;
        padding: 4px;
    }

    #dock-inner button:hover {
        background-color: rgba(255, 255, 255, 0.10);
    }
    
    #dock-inner button.launching {
        background-color: rgba(0, 150, 255, 0.25);
        box-shadow: 0 0 8px rgba(0, 150, 255, 0.4);
    }
    
    #dock-inner separator {
        background: transparent;
        color: rgba(255, 255, 255, 0.2);
    }
    """

    style_provider = Gtk.CssProvider()
    style_provider.load_from_data(css)

    screen = Gdk.Screen.get_default()
    Gtk.StyleContext.add_provider_for_screen(
        screen,
        style_provider,
        Gtk.STYLE_PROVIDER_PRIORITY_USER,
    )


def main():
    add_css()

    win = DockWindow()
    win.connect("destroy", Gtk.main_quit)
    Gtk.main()


if __name__ == "__main__":
    main()