#!/bin/bash

# __   __    _   _ _   _ ___  __
# \ \ / /__ | | | | \ | (_) \/ /
#  \ V / _ \| | | |  \| | |\  / 
#   | | (_) | |_| | |\  | |/  \ 
#   |_|\___/ \___/|_| \_|_/_/\_\
#
# License GPL3
# Homepage: https://github.com/apapamarkou/younix
# Author: Andrianos Papamarkou
# Email: papamarkoua@gmail.com

#
# YoUNiX Time Machine
#

SCRIPT_NAME=$(basename "$0")
TITLE="Time Machine"
BASE_FOLDER_NAME="time-machine"
CONFIG_DIR="$HOME/.config/$BASE_FOLDER_NAME"
CONFIG_FILE="$CONFIG_DIR/config"

# Default values
DESTINATION=""
DAILY_ENABLED=false
WEEKLY_ENABLED=false
MONTHLY_ENABLED=false
DAILY_BACKUPS=7
WEEKLY_BACKUPS=4
MONTHLY_BACKUPS=12

showHelp() {
    echo "$DISTRO_NAME $TITLE"
    echo "Usage: $SCRIPT_NAME [OPTIONS]"
    echo "Options:"
    echo "  -t    Open in terminal"
    echo "  -b    Create backup snapshot"
    echo "  -n    Backup name (daily/weekly/monthly)"
    echo "  -h    Show this help"
}

openTerminal() {
    nohup flock -n $LOCK_DIR/$SCRIPT_NAME.lock terminal --columns=80 --lines=20 --title="$FLOATING_PREFIX $TITLE" $SCRIPT_NAME > /dev/null 2>&1 &
}

loadConfig() {
    mkdir -p "$CONFIG_DIR"
    [[ -f "$CONFIG_FILE" ]] && source "$CONFIG_FILE"
}

saveConfig() {
    cat > "$CONFIG_FILE" << EOF
DESTINATION="$DESTINATION"
DAILY_ENABLED=$DAILY_ENABLED
WEEKLY_ENABLED=$WEEKLY_ENABLED
MONTHLY_ENABLED=$MONTHLY_ENABLED
DAILY_BACKUPS=$DAILY_BACKUPS
WEEKLY_BACKUPS=$WEEKLY_BACKUPS
MONTHLY_BACKUPS=$MONTHLY_BACKUPS
EOF
}

enterPathManually() {
    while true; do
        clear
        yprint -c --color=yellow "$DISTRO_NAME $TITLE"
        echo

        ERROR_TEXT=""
        INPUT_PATH=""
        read -e -p "Enter timemachine destination path: " INPUT_PATH

        # if empty or directory not exist ask for [R]etry or [A]bort
        if [[ -z "$INPUT_PATH" ]]; then
            ERROR_TEXT="Path cannot be empty"
        elif [[ ! -d "$INPUT_PATH" ]]; then
            ERROR_TEXT="Path does not exist"
        fi
        if [[ -n "$ERROR_TEXT" ]]; then
            echo
            yprint --color=red "$ERROR_TEXT"
            echo
            echo "Press [R] to retry or [A]to abort..."
            local choice
            while true; do
                read -n1 -s choice
                if [[ "$choice" =~ [Rr] ]]; then
                    break
                elif [[ "$choice" =~ [Aa] ]]; then
                    return
                fi
            done
            
        fi
        DESTINATION=$INPUT_PATH
        return
    done

}

selectDestination() {
    height=$(($(tput lines) - 1))
    local choice=$(echo -e "  Browse for folder\n  Enter path manually\n󰌍  Back" | fzf --layout=reverse --prompt="Select destination method > " --height=$height)
    
    case "$choice" in
        *"Browse"*)
            DESTINATION=$(find /mnt /media /home -maxdepth 3 -type d 2>/dev/null | fzf --layout=reverse --prompt="Select backup destination > " --height=$height)
            ;;
        *"Enter path"*)
            enterPathManually
            ;;
        *) 
            return
            ;;
    esac
    
    [[ -n "$DESTINATION" ]] && {
        sudo mkdir -p "$DESTINATION/$BASE_FOLDER_NAME"
        sudo chmod 755 "$DESTINATION/$BASE_FOLDER_NAME"
        DESTINATION="$DESTINATION/$BASE_FOLDER_NAME"
        saveConfig
        yprint --color=green "Destination set to: $DESTINATION"
        sleep 2
    }
}

createSnapshot() {
    local backup_name="$1"
    local interactive="$2"
    
    [[ "$interactive" == "true" ]] && clear
    [[ -z "$DESTINATION" ]] && { yprint --color=red "No destination selected"; [[ "$interactive" == "true" ]] && read -p "Press Enter..."; return; }
    
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local snapshot_name="$timestamp-time-machine-snapshot"
    [[ -n "$backup_name" ]] && snapshot_name="$timestamp-$backup_name-time-machine-snapshot"
    local snapshot_path="$DESTINATION/$snapshot_name"
    
    # Find latest snapshot for hardlinks
    local latest_snapshot=$(ls -1t "$DESTINATION"/snapshot-* 2>/dev/null | head -1)
    
    yprint --color=yellow "Creating snapshot: $snapshot_name"
    [[ "$interactive" == "true" ]] && echo
    
    # Build rsync command
    local rsync_cmd="rsync -avH --delete"
    [[ "$interactive" != "true" ]] && rsync_cmd="$rsync_cmd --quiet"
    rsync_cmd="$rsync_cmd --exclude={'/dev/*','/home/*','/proc/*','/sys/*','/tmp/*','/run/*','/mnt/*','/media/*','/lost+found'}"
    
    [[ -n "$latest_snapshot" ]] && rsync_cmd="$rsync_cmd --link-dest=$latest_snapshot"
    
    rsync_cmd="$rsync_cmd / $snapshot_path/"
    
    if [[ "$interactive" == "true" ]]; then
        # Interactive mode with progress bar
        local frames=(
            "[        ]  Backing up files..."
            "[=       ]  Backing up files..."
            "[==      ]  Backing up files..."
            "[===     ]  Backing up files..."
            "[====    ]  Backing up files..."
            "[ ====   ]  Backing up files..."
            "[  ====  ]  Backing up files..."
            "[   ==== ]  Backing up files..."
            "[    ====]  Backing up files..."
            "[     ===]  Backing up files..."
            "[      ==]  Backing up files..."
            "[       =]  Backing up files..."
        )
        local i=0
        eval $rsync_cmd &
        
        local rsync_pid=$!
        
        while kill -0 $rsync_pid 2>/dev/null; do
            printf "\r%s" "${frames[$i]}"
            i=$(((i+1) % ${#frames[@]}))
            sleep 0.1
            read -t 0.1 -n 1 key 2>/dev/null
            if [[ "$key" == "A" || "$key" == "a" ]]; then
                kill $rsync_pid 2>/dev/null
                printf "\r"
                yprint --color=red "  Snapshot creation aborted!"
                read -p "Press Enter to continue..."
                return
            fi
        done
        printf "\r"
        notify-send "Snapshot Created" \
            "Snapshot $snapshot_name created successfully at $DESTINATION."
    else
        # Non-interactive mode
        eval $rsync_cmd
    fi
    
    wait $rsync_pid 2>/dev/null
    local exit_code=$?
    
    if [[ $exit_code -eq 0 ]]; then
        yprint --color=green "  Snapshot created successfully!"
        notify-send "Snapshot Created" \
            "Snapshot $snapshot_name created successfully at $DESTINATION."
        
        # Clean old backups based on retention policy
        [[ -n "$backup_name" ]] && cleanOldBackups "$backup_name"
    else
        yprint --color=red "󰬅  Snapshot creation failed!"
        notify-send -u critical "Snapshot Failed" \
            "Failed to create snapshot $snapshot_name. Check logs for details."
    fi
    
    [[ "$interactive" == "true" ]] && read -p "Press Enter to continue..."
}

toggleDaily() {
    if [[ "$DAILY_ENABLED" == true ]]; then
        DAILY_ENABLED=false
        sudo systemctl stop ytimemachine-daily.timer
        sudo systemctl disable ytimemachine-daily.timer
    else
        DAILY_ENABLED=true
        createSystemdFiles "daily"
    fi
    saveConfig
}

toggleWeekly() {
    if [[ "$WEEKLY_ENABLED" == true ]]; then
        WEEKLY_ENABLED=false
        sudo systemctl stop ytimemachine-weekly.timer
        sudo systemctl disable ytimemachine-weekly.timer
    else
        WEEKLY_ENABLED=true
        createSystemdFiles "weekly"
    fi
    saveConfig
}

toggleMonthly() {
    if [[ "$MONTHLY_ENABLED" == true ]]; then
        MONTHLY_ENABLED=false
        sudo systemctl stop ytimemachine-monthly.timer
        sudo systemctl disable ytimemachine-monthly.timer
    else
        MONTHLY_ENABLED=true
        createSystemdFiles "monthly"
    fi
    saveConfig
}

setDailyCount() {
    height=$(($(tput lines) - 1))
    local count=$(seq 1 7 | fzf --layout=reverse --prompt="Select daily backups to keep > " --height=$height)
    [[ -n "$count" ]] && {
        DAILY_BACKUPS=$count
        saveConfig
    }
}

setWeeklyCount() {
    height=$(($(tput lines) - 1))
    local count=$(seq 1 4 | fzf --layout=reverse --prompt="Select weekly backups to keep > " --height=$height)
    [[ -n "$count" ]] && {
        WEEKLY_BACKUPS=$count
        saveConfig
    }
}

setMonthlyCount() {
    height=$(($(tput lines) - 1))
    local count=$(seq 1 12 | fzf --layout=reverse --prompt="Select monthly backups to keep > " --height=$height)
    [[ -n "$count" ]] && {
        MONTHLY_BACKUPS=$count
        saveConfig
    }
}

cleanOldBackups() {
    local backup_type="$1"
    local keep_count
    
    case "$backup_type" in
        "daily") keep_count=$DAILY_BACKUPS ;;
        "weekly") keep_count=$WEEKLY_BACKUPS ;;
        "monthly") keep_count=$MONTHLY_BACKUPS ;;
        *) return ;;
    esac
    
    # Get list of backups for this type, sorted by date (newest first)
    local backups=$(ls -1t "$DESTINATION"/ 2>/dev/null | grep "$backup_type-time-machine-snapshot")
    local count=$(echo "$backups" | wc -l)
    
    # Delete old backups if count exceeds keep_count
    if [[ $count -gt $keep_count ]]; then
        echo "$backups" | tail -n +$((keep_count + 1)) | while read -r old_backup; do
            sudo rm -rf "$DESTINATION/$old_backup"
        done
    fi
}

restoreSnapshot() {
    local snapshot="$1"
    height=$(($(tput lines) - 1))

    # Επιλογή Restore / Cancel
    local choice=$(echo -e "󰦛  Restore\n󰬅  Cancel" | fzf \
        --layout=reverse \
        --prompt="Restore $snapshot? This will overwrite current system! " \
        --height=$height)

    [[ "$choice" =~ "Restore" ]] || return

    clear

    # ---- SAFETY CHECK: Must be Live ISO ----
    if [[ ! -e /run/archiso/bootmnt ]]; then
        yprint --color=red "ERROR: Restore can ONLY be executed from an Arch Live ISO!"
        echo
        echo "Reboot into an Arch Live environment and run this tool again."
        read -p "Press Enter to return..."
        return
    fi
    # -----------------------------------------

    # Select partition to restore to
    local partitions=$(lsblk -rno NAME,SIZE,TYPE,MOUNTPOINT | awk '$3=="part" && $4=="" {print "/dev/"$1" ("$2")"}' | sort)
    [[ -z "$partitions" ]] && { yprint --color=red "No available partitions found!"; read -p "Press Enter..."; return; }
    
    local selected_partition=$(echo "$partitions" | fzf --layout=reverse --prompt="Select partition to restore to > " --height=$height)
    [[ -z "$selected_partition" ]] && return
    
    local DRIVE_PATH=$(echo "$selected_partition" | cut -d' ' -f1)
    
    echo "You are in Live ISO — restore is allowed."
    echo "Target partition: $selected_partition"
    echo
    read -p "Type 'RESTORE' to proceed: " confirm
    [[ "$confirm" != "RESTORE" ]] && return

    yprint --color=red "Restoring snapshot: $snapshot"

    # Mount του root
    RESTORE_MOUNT_POINT="/mnt/restore"
    mkdir -p "$RESTORE_MOUNT_POINT"
    mount "$DRIVE_PATH" "$RESTORE_MOUNT_POINT"

    # Restore αρχείων
    rsync -avH --delete \
        --exclude='/dev/*' \
        --exclude='/proc/*' \
        --exclude='/sys/*' \
        --exclude='/run/*' \
        --exclude='/home/*' \
        --exclude='/tmp/*' \
        "$DESTINATION/$snapshot/" "$RESTORE_MOUNT_POINT/"

    # Bind mounts
    mount --bind /dev  "$RESTORE_MOUNT_POINT/dev"
    mount --bind /proc "$RESTORE_MOUNT_POINT/proc"
    mount --bind /sys  "$RESTORE_MOUNT_POINT/sys"

    # Chroot
    arch-chroot "$RESTORE_MOUNT_POINT" /bin/bash -c "
        mkinitcpio -P
        grub-mkconfig -o /boot/grub/grub.cfg
    "

    umount -R "$RESTORE_MOUNT_POINT"

    yprint --color=green "Restore completed! Reboot now."
    read -p "Press Enter..."
}


deleteSnapshot() {
    local snapshot="$1"
    height=$(($(tput lines) - 1))
    local choice=$(echo -e "󰆴  Delete\n󰬅  Cancel" | fzf --layout=reverse --prompt="Delete $snapshot? " --height=$height)
    
    [[ "$choice" =~ "Delete" ]] && {
        # remove with no output
        echo
        sudo rm -rf "$DESTINATION/$snapshot" 2>/dev/null
        yprint --color=green "Snapshot deleted!"
        echo
        read -p "Press Enter to continue..."
    }
}

renameSnapshot() {
    local snapshot="$1"
    local timestamp=$(echo "$snapshot" | cut -d'-' -f1)
    local current_name=$(echo "$snapshot" | cut -d'-' -f2-)
    read -e -p "Enter new name: " -i "$current_name" new_name
    [[ -n "$new_name" ]] && {
        local new_snapshot="$timestamp-$new_name"
        sudo mv "$DESTINATION/$snapshot" "$DESTINATION/$new_snapshot"
        yprint --color=green "Snapshot renamed!"
        read -p "Press Enter to continue..."
    }
}

viewSnapshotDetails() {
    local snapshot="$1"
    local snapshot_path="$DESTINATION/$snapshot"
    echo
    echo -e "\033[36mSnapshot:\033[0m $snapshot"
    echo -e "\033[36mPath:\033[0m $snapshot_path"
    echo -e "\033[36mSize:\033[0m $(du -sh "$snapshot_path" 2>/dev/null | cut -f1)"
    echo -e "\033[36mCreated:\033[0m $(stat -c %y "$snapshot_path" 2>/dev/null)"
    echo -e "\033[36mFiles:\033[0m $(find "$snapshot_path" -type f 2>/dev/null | wc -l)"
    echo
    read -p "Press Enter to continue..."
}

snapshotMenu() {
    local snapshot="$1"
    while true; do
        [[ ! -d "$DESTINATION/$snapshot" ]] && return
        clear
        yprint -c --color=yellow "Snapshot: $snapshot"
        height=$(($(tput lines) - 1))
        choice=$(echo -e "󰦛  Restore This Snapshot\n󰆴  Delete Snapshot\n󰑕  Rename Snapshot\n  View Snapshot Details\n󰌍  Back to Main Menu" | fzf \
            --layout=reverse \
            --prompt="  Select action > " \
            --height=$height)
        
        [[ -z "$choice" ]] && break
        
        case "$choice" in
            *"Restore"*) restoreSnapshot "$snapshot" ;;
            *"Delete"*) deleteSnapshot "$snapshot" ;;
            *"Rename"*) renameSnapshot "$snapshot" ;;
            *"View"*) viewSnapshotDetails "$snapshot" ;;
            *"Back"*) break ;;
        esac
    done
}

createSystemdFiles() {
    local name="$1"
    local service_file="/etc/systemd/system/ytimemachine-$name.service"
    local timer_file="/etc/systemd/system/ytimemachine-$name.timer"
    
    sudo tee "$service_file" > /dev/null << EOF
[Unit]
Description=YoUNiX Time Machine $name Backup
Wants=ytimemachine-$name.timer

[Service]
Type=oneshot
ExecStart=/home/user/.local/bin/ytimemachine -b -n $name
User=root

[Install]
WantedBy=multi-user.target
EOF
    
    local schedule
    case "$name" in
        "daily") schedule="daily" ;;
        "weekly") schedule="weekly" ;;
        "monthly") schedule="monthly" ;;
    esac
    
    sudo tee "$timer_file" > /dev/null << EOF
[Unit]
Description=YoUNiX Time Machine $name Backup Timer
Requires=ytimemachine-$name.service

[Timer]
OnCalendar=$schedule
Persistent=true

[Install]
WantedBy=timers.target
EOF
    
    sudo systemctl daemon-reload
    sudo systemctl enable "ytimemachine-$name.timer"
    sudo systemctl start "ytimemachine-$name.timer"
}

displayMenu() {
    loadConfig
    
    while true; do
        # if STARTUP is empty show welcome
        clear
        if [[ -z "$STARTUP" ]]; then
            yprint -c --color=cyan --figlet "Time Machine"
            yprint -c --color=yellow "Time machine need elevated privileges"
            echo
            echo
            sudo clear
            STARTUP="pass"
        fi
        
        
        
        yprint -c --color=yellow "$DISTRO_NAME $TITLE"
        
        # Build dynamic menu
        local dest_text="  Select Destination first!"
        [[ -n "$DESTINATION" ]] && dest_text="  Change Destination ($DESTINATION)"
        
        local daily_text="  Enable Daily Backups"
        [[ "$DAILY_ENABLED" == true ]] && daily_text="  Disable Daily Backups"
        
        local weekly_text="  Enable Weekly Backups"
        [[ "$WEEKLY_ENABLED" == true ]] && weekly_text="  Disable Weekly Backups"
        
        local monthly_text="  Enable Monthly Backups"
        [[ "$MONTHLY_ENABLED" == true ]] && monthly_text="  Disable Monthly Backups"
        
        # Build options
        local options="$dest_text\n󰈆  Exit"
        
        if [[ -n "$DESTINATION" ]]; then
            options="  Create Snapshot now\n$dest_text\n$daily_text"
            [[ "$DAILY_ENABLED" == true ]] && options="$options\n󰆼  Keep $DAILY_BACKUPS Daily Backups"
            options="$options\n$weekly_text"
            [[ "$WEEKLY_ENABLED" == true ]] && options="$options\n󰆼  Keep $WEEKLY_BACKUPS Weekly Backups"
            options="$options\n$monthly_text"
            [[ "$MONTHLY_ENABLED" == true ]] && options="$options\n󰆼  Keep $MONTHLY_BACKUPS Monthly Backups"
            options="$options\n󰈆  Exit"
        fi
        
        # Add snapshots if destination exists
        if [[ -n "$DESTINATION" && -d "$DESTINATION" ]]; then
            local snapshots=$(ls -1t "$DESTINATION"/ 2>/dev/null | xargs -r -n1 basename | sed $'s/.*/\e[36m&\e[0m/')

            [[ -n "$snapshots" ]] && options="$options\n$snapshots"
        fi
        
        height=$(($(tput lines) - 1))
        choice=$(echo -e "$options" | fzf \
            --ansi \
            --layout=reverse \
            --prompt="  Select option > " \
            --height=$height)
        
        [[ -z "$choice" ]] && exit 0
        
        case "$choice" in
            *"Create Snapshot"*) createSnapshot "" "true" ;;
            *"Destination"*) selectDestination ;;
            *"Keep"*" Daily"*) setDailyCount ;;
            *"Keep"*" Weekly"*) setWeeklyCount ;;
            *"Keep"*" Monthly"*) setMonthlyCount ;;
            *"Daily Backups"*) toggleDaily ;;
            *"Weekly Backups"*) toggleWeekly ;;
            *"Monthly Backups"*) toggleMonthly ;;
            *"Exit"*) exit 0 ;;
            *-*) snapshotMenu "$choice" ;;
        esac
    done
}

OPEN_TERMINAL=false
BACKUP_MODE=false
BACKUP_NAME=""

while getopts "tbn:h" opt; do
    case $opt in
        t) OPEN_TERMINAL=true ;;
        b) BACKUP_MODE=true ;;
        n) BACKUP_NAME="$OPTARG" ;;
        h) showHelp; exit 0 ;;
        \?) echo "Invalid option. Use -h for help."; exit 1 ;;
    esac
done

if [[ "$BACKUP_MODE" == true ]]; then
    loadConfig
    createSnapshot "$BACKUP_NAME" "false"
    exit 0
fi

if [[ "$OPEN_TERMINAL" == true ]]; then
    openTerminal
    exit 0
fi

displayMenu